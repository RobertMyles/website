---
title: Hmm...where to move to? Using R & D3 to decide where to live (kind of).
author: Robert Myles McDonnell
date: '2018-03-25'
slug: hmm-where-to-move
categories: [R, D3]
tags: []
draft: false
output:
  html_document:
    includes:
      after_body: radar_index.html
---

Myself and my wife have been thinking about where we'd like to move in the future. We have 5 cities in mind. The things that matter to us (that I could get data on, or are relevant/measurable) are the climate, crime, the cost of living, the type of salary we could get, if the city is near to the sea and beach (I like being close to the sea) and if a city is very big (large population). We live in SÃ£o Paulo, so we're kind of due a break from having *millions* of people around us all the time.  
The cost of living stats, which are relative to NY (i.e. 100 = NY), I got from [numbeo](https://www.numbeo.com/cost-of-living/rankings.jsp). Salary stats I got from Google searches, mainly leading to indeed.com (for Berlin I found only the German national average, and Lisbon is a bit of a guess, there was nothing that I found). Temperatures I found on Wikipedia, and all currency values were converted to Euro skrilla `r emo::ji("euro")`. The crime index also comes from numbeo. I put these in a tibble and rescaled all the values, inverting the winter temps so that lower ones mean higher values on the plot:   

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(scales)

cities <- tibble(
  city = c("Cork", "Vancouver", "Perth", "Lisbon", "Berlin"),
  av_winter_temp = c(5.6, 3.5, 13, 11.6, 1),
  av_summer_temp = c(15.3, 18, 25, 23.5, 19.2),
  av_min_winter_temp = c(3, 1, 7.7, 8, -2),
  av_max_summer_temp = c(18.7, 22, 32.3, 28.3, 25),
  median_salary = c(55000, 60000, 60000, 45000, 52000),
  gdp_per_capita = c(50544, 36000, 45000, 30000, 35600),
  crime_index = c(29.19, 35.96, 43.93, 33.53, 40.97),
  population = c(208669, 631486, 2022044, 552700, 3700000),
  distance_to_beach = c(25, 0, 0, 0, 145),
  cost_of_living = c(82.89, 75.59, 86.24, 57.69, 74.32)
) %>% mutate_at(vars(-city),funs(rescale)) %>% 
  mutate(av_min_winter_temp = 1- av_min_winter_temp,
         av_winter_temp = 1 - av_winter_temp)

```

  
So now we've got our data. What I wanted to do in this post was to maintain the data in the document and send to D3 (as in [this](https://towardsdatascience.com/getting-r-and-d3-js-to-play-nicely-in-r-markdown-270e302a52d3) post and [this](http://livefreeordichotomize.com/2017/01/24/custom-javascript-visualizations-in-rmarkdown/) one), however, I was unable to create the JSON in the exact format I needed for use with [Micah Stubb's](https://bl.ocks.org/micahstubbs/a772306d6fd49874ec92)/[Nadieh Bremer's](https://www.visualcinnamon.com/2015/10/different-look-d3-radar-chart.html)/[Alvaro Graves'](https://github.com/alangrafu/radar-chart-d3) D3 Radar Chart. So I had to do that manually...`r emo::ji("frowning_face")`.  
  
Well, enough blathering, here's the pretty chart. You can hover over the chart to highlight certain cities, or hover over the legend to do the same thing. Hovering over the points themselves will give you the percentage value relative to the other cities (the absolute values in the original data would be cooler, but I couldn't figure out how to do that).   

<div class="radarChart"></div>

So what makes a city 'good' here? Low-to-medium values for population and cost of living, low crime and not-too-high summer temperatures, not-too-low winter temperatures, nice salaries, high GDP and short distance to the beach. None of the cities are perfect (of course not!), but ol' Cork doesn't come out too bad. Vancouver, too. Remember that the winter temperatures were inversed, so Lisbon looks great in terms of the climate, and its low cost of living. It's also by the beach, something Cork isn't exactly (although there are amazing beaches not too far away). Perth came out OK on our list, after many years of hot weather, I think I might need a break (my skin definitely does), although I'm not sure I like the cold of Berlin, or its bigger population. So which one will we choose? That'd be telling...
  

The JavaScript code used to make this is as follows:  

```
var margin = {top: 100, right: 100, bottom: 100, left: 100},
legendPosition = {x: 25, y: 25},
width = Math.min(700, window.innerWidth - 10) - margin.left - margin.right,
height = Math.min(width, window.innerHeight - margin.top - margin.bottom - 20);

var color = d3.scale.ordinal()
.range(["#41D3BD","#F0C987","#791E94", "#DE6449", "#407899"]);

var radarChartOptions = {
  w: width,
  h: height,
  margin: margin,
  legendPosition: legendPosition,
  maxValue: 1,
  wrapWidth: 60,
  levels: 5,
  roundStrokes: true,
  color: color,
  axisName: "reason",
  areaName: "city",
  value: "value"
};

//Load the data and Call function to draw the Radar chart
d3.json("data2.json", function(error, data){
RadarChart(".radarChart", data, radarChartOptions);
});

```
  
This is combined with the `RadarChart()` function that you see above, and creating a div in the RMarkdown (`<div class="radarChart"></div>`). This div has the class `.radarChart`, which you will see referenced in `radar_index.html`, which is included in the blogdown YAML. The relevant part is:   

```
output:
  html_document:
    includes:
      after_body: radar_index.html
      
``` 

The content of `radar_index.html` can be seen from the element inspector in your browser, but I'll put it here for ease:  

```
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/ >
		<title></title>

		<!-- Google fonts -->
		<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300' rel='stylesheet' type='text/css'>
		<link href='https://fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>

		<!-- D3.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/1.3.0/d3-legend.js" charset="utf-8"></script>
		
		<style>
			.radarChart {
				font-family: 'Open Sans', sans-serif;
				font-size: 11px;
				font-weight: 300;
				fill: #242424;
				text-align: center;
				text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff;
				cursor: default;
			}
			
			.tooltip {
				fill: #333333;
			}
		</style>
	
	</head>
</html>
```

These are both combined with the `RadarChart()` function, which is basically the same as Micah's, except I took out the fuzzy glow part, and changed the colours of both the main palette and the circle backgrounds. The code and inspiration for all of this comes from the talented D3-ers linked to above (Nadieh, Micah and Alvaro).  

```
function RadarChart(id, data, options) {
	var cfg = {
	 w: 600,				//Width of the circle
	 h: 600,				//Height of the circle
	 margin: {top: 20, right: 20, bottom: 20, left: 20}, //The margins around the circle
	 legendPosition: {x: 20, y: 20}, // the position of the legend, from the top-left corner of the svg
	 levels: 3,				//How many levels or inner circles should there be drawn
	 maxValue: 0, 				//What is the value that the biggest circle will represent
	 labelFactor: 1.25, 			//How much farther than the radius of the outer circle should the labels be placed
	 wrapWidth: 60, 			//The number of pixels after which a label needs to be given a new line
	 opacityArea: 0.35, 			//The opacity of the area of the blob
	 dotRadius: 4, 				//The size of the colored circles of each blog
	 opacityCircles: 0.1, 			//The opacity of the circles of each blob
	 strokeWidth: 2, 			//The width of the stroke around each blob
	 roundStrokes: false,			//If true the area and stroke will follow a round path (cardinal-closed)
	 color: d3.scale.category10(),		//Color function
	 axisName: "axis",
	 areaName:"areaName",
	 value: "value",
	 sortAreas: true,
	};
	
	//Put all of the options into a variable called cfg
	if('undefined' !== typeof options){
	  for(var i in options){
		if('undefined' !== typeof options[i]){ cfg[i] = options[i]; }
	  }//for i
	}//if

	//Map the fields specified in the configuration 
	// to the axis and value variables
	var axisName = cfg["axisName"],
			areaName = cfg["areaName"],
			value = cfg["value"];

	//Calculate the average value for each area
	data.forEach(function(d){
		d[value + "Average"] = d3.mean(d.values, function(e){ return e[value] }); 
	})

	//Sort the data for the areas from largest to smallest
	//by average value as an approximation of actual blob area
	//so that that the smallest area is drawn last
	//and therefore appears on top
	data = data.sort(function(a, b){
		var a = a[value + "Average"],
				b = b[value + "Average"];
		return b - a;
	})
	
	//Convert the nested data passed in
	// into an array of values arrays
	data = data.map(function(d) { return d.values })

	//If the supplied maxValue is smaller than the actual one, replace by the max in the data
	var maxValue = Math.max(cfg.maxValue, d3.max(data, function(i){
		return d3.max(i.map(
			function(o){ return o[value]; }
		))
	}));
		
	var allAxis = (data[0].map(function(d, i){ return d[axisName] })),	//Names of each axis
		total = allAxis.length,					//The number of different axes
		radius = Math.min(cfg.w/2, cfg.h/2), 			//Radius of the outermost circle
		Format = d3.format('%'),			 	//Percentage formatting
		angleSlice = Math.PI * 2 / total;			//The width in radians of each "slice"

	//Scale for the radius
	var rScale = d3.scale.linear()
		.range([0, radius])
		.domain([0, maxValue]);
		
	/////////////////////////////////////////////////////////
	//////////// Create the container SVG and g /////////////
	/////////////////////////////////////////////////////////

	//Remove whatever chart with the same id/class was present before
	d3.select(id).select("svg").remove();
	
	//Initiate the radar chart SVG
	var svg = d3.select(id).append("svg")
			.attr("width",  cfg.w + cfg.margin.left + cfg.margin.right)
			.attr("height", cfg.h + cfg.margin.top + cfg.margin.bottom)
			.attr("class", "radar"+id);
	//Append a g element		
	var g = svg.append("g")
			.attr("transform", "translate(" + (cfg.w/2 + cfg.margin.left) + "," + (cfg.h/2 + cfg.margin.top) + ")");
	
	//Wrapper for the grid & axes
	var axisGrid = g.append("g").attr("class", "axisWrapper");
	
	//Draw the background circles
	axisGrid.selectAll(".levels")
	   .data(d3.range(1,(cfg.levels+1)).reverse())
	   .enter()
		.append("circle")
		.attr("class", "gridCircle")
		.attr("r", function(d, i){return radius/cfg.levels*d;})
		.style("fill", "white")
		.style("stroke", "#CDCDCD");

	//Text indicating at what % each level is
	axisGrid.selectAll(".axisLabel")
	   .data(d3.range(1,(cfg.levels+1)).reverse())
	   .enter().append("text")
	   .attr("class", "axisLabel")
	   .attr("x", 4)
	   .attr("y", function(d){return -d*radius/cfg.levels;})
	   .attr("dy", "0.4em")
	   .style("font-size", "10px")
	   .attr("fill", "#737373")
	   .text(function(d,i) { return Format(maxValue * d/cfg.levels); });
	
	//Create the straight lines radiating outward from the center
	var axis = axisGrid.selectAll(".axis")
		.data(allAxis)
		.enter()
		.append("g")
		.attr("class", "axis");
	//Append the lines
	axis.append("line")
		.attr("x1", 0)
		.attr("y1", 0)
		.attr("x2", function(d, i){ return rScale(maxValue*1.1) * Math.cos(angleSlice*i - Math.PI/2); })
		.attr("y2", function(d, i){ return rScale(maxValue*1.1) * Math.sin(angleSlice*i - Math.PI/2); })
		.attr("class", "line")
		.style("stroke", "white")
		.style("stroke-width", "2px");

	//Append the labels at each axis
	axis.append("text")
		.attr("class", "legend")
		.style("font-size", "11px")
		.attr("text-anchor", "middle")
		.attr("dy", "0.35em")
		.attr("x", function(d, i){ return rScale(maxValue * cfg.labelFactor) * Math.cos(angleSlice*i - Math.PI/2); })
		.attr("y", function(d, i){ return rScale(maxValue * cfg.labelFactor) * Math.sin(angleSlice*i - Math.PI/2); })
		.text(function(d){return d})
		.call(wrap, cfg.wrapWidth);
	
	//The radial line function
	var radarLine = d3.svg.line.radial()
		.interpolate("linear-closed")
		.radius(function(d) { return rScale(d[value]); })
		.angle(function(d,i) {	return i*angleSlice; });
		
	if(cfg.roundStrokes) {
		radarLine.interpolate("cardinal-closed");
	}
				
	//Create a wrapper for the blobs	
	var blobWrapper = g.selectAll(".radarWrapper")
		.data(data)
		.enter().append("g")
		.attr("class", "radarWrapper");
			
	//Append the backgrounds	
	blobWrapper
		.append("path")
		.attr("class", function(d) {
			return "radarArea" + " " + d[0][areaName].replace(/\s+/g, '') //Remove spaces from the areaName string to make one valid class name
		})
		.attr("d", function(d,i) { return radarLine(d); })
		.style("fill", function(d,i) { return cfg.color(i); })
		.style("fill-opacity", cfg.opacityArea)
		.on('mouseover', function (d,i){
			console.log("d", d);
			console.log("this", this);
			//Dim all blobs
			d3.selectAll(".radarArea")
				.transition().duration(200)
				.style("fill-opacity", 0.1); 
			//Bring back the hovered over blob
			d3.select(this)
				.transition().duration(200)
				.style("fill-opacity", 0.7);	
		})
		.on('mouseout', function(){
			//Bring back all blobs
			d3.selectAll(".radarArea")
				.transition().duration(200)
				.style("fill-opacity", cfg.opacityArea);
		});
		
	//Create the outlines	
	blobWrapper.append("path")
		.attr("class", "radarStroke")
		.attr("d", function(d,i) { return radarLine(d); })
		.style("stroke-width", cfg.strokeWidth + "px")
		.style("stroke", function(d,i) { return cfg.color(i); })
		.style("fill", "none")
		.style("filter" , "url(#glow)");		
	
	//Append the circles
	blobWrapper.selectAll(".radarCircle")
		.data(function(d,i) { return d; })
		.enter().append("circle")
		.attr("class", "radarCircle")
		.attr("r", cfg.dotRadius)
		.attr("cx", function(d,i){ return rScale(d[value]) * Math.cos(angleSlice*i - Math.PI/2); })
		.attr("cy", function(d,i){ return rScale(d[value]) * Math.sin(angleSlice*i - Math.PI/2); })
		.style("fill", function(d,i,j) { return cfg.color(j); })
		.style("fill-opacity", 0.8);
	
	//Wrapper for the invisible circles on top
	var blobCircleWrapper = g.selectAll(".radarCircleWrapper")
		.data(data)
		.enter().append("g")
		.attr("class", "radarCircleWrapper");
		
	//Append a set of invisible circles on top for the mouseover pop-up
	blobCircleWrapper.selectAll(".radarInvisibleCircle")
		.data(function(d,i) { return d; })
		.enter().append("circle")
		.attr("class", "radarInvisibleCircle")
		.attr("r", cfg.dotRadius*1.5)
		.attr("cx", function(d,i){ return rScale(d[value]) * Math.cos(angleSlice*i - Math.PI/2); })
		.attr("cy", function(d,i){ return rScale(d[value]) * Math.sin(angleSlice*i - Math.PI/2); })
		.style("fill", "none")
		.style("pointer-events", "all")
		.on("mouseover", function(d,i) {
			newX =  parseFloat(d3.select(this).attr('cx')) - 10;
			newY =  parseFloat(d3.select(this).attr('cy')) - 10;
					
			tooltip
				.attr('x', newX)
				.attr('y', newY)
				.text(Format(d[value]))
				.transition().duration(200)
				.style('opacity', 1);
		})
		.on("mouseout", function(){
			tooltip.transition().duration(200)
				.style("opacity", 0);
		});
		
	//Set up the small tooltip for when you hover over a circle
	var tooltip = g.append("text")
		.attr("class", "tooltip")
		.style("opacity", 0);
	
	/////////////////////////////////////////////////////////
	/////////////////// Helper Functions ////////////////////
	/////////////////////////////////////////////////////////

	//Taken from http://bl.ocks.org/mbostock/7555321
	//Wraps SVG text	
	function wrap(text, width) {
	  text.each(function() {
		var text = d3.select(this),
			words = text.text().split(/\s+/).reverse(),
			word,
			line = [],
			lineNumber = 0,
			lineHeight = 1.4, // ems
			y = text.attr("y"),
			x = text.attr("x"),
			dy = parseFloat(text.attr("dy")),
			tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
			
		while (word = words.pop()) {
		  line.push(word);
		  tspan.text(line.join(" "));
		  if (tspan.node().getComputedTextLength() > width) {
			line.pop();
			tspan.text(line.join(" "));
			line = [word];
			tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
		  }
		}
	  });
	}//wrap	

	// on mouseover for the legend symbol
	function cellover(d) {
			//Dim all blobs
			d3.selectAll(".radarArea")
				.transition().duration(200)
				.style("fill-opacity", 0.1); 
			//Bring back the hovered over blob
			d3.select("." + data[d][0][areaName].replace(/\s+/g, ''))
				.transition().duration(200)
				.style("fill-opacity", 0.7);	
	}

	// on mouseout for the legend symbol
	function cellout() {
		//Bring back all blobs
		d3.selectAll(".radarArea")
			.transition().duration(200)
			.style("fill-opacity", cfg.opacityArea);
	}

	/////////////////////////////////////////////////////////
	/////////////////// Draw the Legend /////////////////////
	/////////////////////////////////////////////////////////

	svg.append("g")
  	.attr("class", "legendOrdinal")
  	.attr("transform", "translate(" + cfg["legendPosition"]["x"] + "," + cfg["legendPosition"]["y"] + ")");

	var legendOrdinal = d3.legend.color()
  //d3 symbol creates a path-string, for example
  //"M0,-8.059274488676564L9.306048591020996,
  //8.059274488676564 -9.306048591020996,8.059274488676564Z"
  	.shape("path", d3.svg.symbol().type("triangle-up").size(150)())
  	.shapePadding(10)
  	.scale(cfg.color)
  	.labels(cfg.color.domain().map(function(d){
  		return data[d][0][areaName];
  	}))
  	.on("cellover", function(d){ cellover(d); })
  	.on("cellout", function(d) { cellout(); });

svg.select(".legendOrdinal")
  .call(legendOrdinal);
}//RadarChart
```	
